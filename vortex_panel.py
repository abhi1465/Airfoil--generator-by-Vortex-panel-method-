# -*- coding: utf-8 -*-
"""Vortex_panel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18gG-PmqRKnaaNiluxmaiIt7dw6-lk501
"""

import matplotlib.pyplot as plt
import numpy as np
from math import sqrt
import math
  
#values of p, m and c
p = 0.4
m = 0.02
c = 1
x1 = np.arange(0,p+0.001,0.001)
# print(x_1)

t = 0.15
yc1 = (m*(2*p*x1-x1*x1))/(p*p)
# print(yc_1)
  
# line 2 points
x2 = np.arange(p,c+0.01,0.001)
yc2 = (m*(1-2*p+2*p*x2-x2*x2))/((1-p)*(1-p))

vector1 = np.vectorize(math.sqrt)
x=np.arange(0,c+0.001,0.001)
#thickness of airfoil from camber line
yt1 = 5*t*(0.2969*vector1(x1)-0.1260*x1-0.3516*x1*x1 + 0.2843*x1*x1*x1 - 0.1015*x1*x1*x1*x1)
yt2 = 5*t*(0.2969*vector1(x2)-0.1260*x2-0.3516*x2*x2+ 0.2843*x2*x2*x2 - 0.1015*x2*x2*x2*x2)


#dyc/dx for using gradient
slope1 = np.gradient(yc1)
slope2 = np.gradient(yc2)

vector2 = np.vectorize(math.atan)

theta1 = vector2(slope1)
theta2 = vector2(slope2)
# print(len(x1), len(yt1), len(theta1), len(slope1), len(yc1))
xu1 = x1 - yt1*np.sin(theta1)
yu1 = yc1 + yt1*np.cos(theta1)
xl1 = x1 + yt1*np.sin(theta1)
yl1 = yc1 - yt1*np.cos(theta1)

xu2 = x2 - yt2*np.sin(theta2)
yu2 = yc2 + yt2*np.cos(theta2)
xl2 = x2 + yt2*np.sin(theta2)
yl2 = yc2 - yt2*np.cos(theta2)

# ##function to find nearest x coordinate to the x which we obtain from  c/1(1-costheta)
def ntx(b):
    xp=0
    j=0
    while(b>xp):
        xp+=0.001
        j+=1
    return [xp,j]

#'''code for nodal coordinates'''
#value of n

n=10


xtemp=[]
delt=(2*3.141592)/(n-1)
for i in range(1,n//2+1,1):
    delta = (-0.5+i)*delt 
    q = 1*(1- np.cos(delta))/2
    
    xtemp.append(q)
xn=[]
nodal_index=[]
for i in range(len(xtemp)):
    xn.append((ntx(xtemp[i]))[0])
    nodal_index.append((ntx(xtemp[i]))[1])

xnl1=[]
ynl1=[]
xnu1=[]
ynu1=[]
xnl2=[]
ynl2=[]
xnu2=[]
ynu2=[]
leno = len(xl1)
for i in range(len(nodal_index)):
    if xn[i]< p:
        xnl1.append(xl1[nodal_index[i]])
        ynl1.append(yl1[nodal_index[i]])
        xnu1.append(xu1[nodal_index[i]])
        ynu1.append(yu1[nodal_index[i]])
    if xn[i] > p:
        xnl2.append(xl2[nodal_index[i]-leno])
        ynl2.append(yl2[nodal_index[i]-leno])
        xnu2.append(xu2[nodal_index[i]-leno])
        ynu2.append(yu2[nodal_index[i]-leno])
       
xnl1=np.array(xnl1)
ynl1=np.array(ynl1)
xnu1=np.array(xnu1)
ynu1=np.array(ynu1)
xnl2=np.array(xnl2)
ynl2=np.array(ynl2)
xnu2=np.array(xnu2)
ynu2=np.array(ynu2)

xlast = [xnl1[0], xnu1[0]]
ylast = [ynl1[0],ynu1[0]]

yfl = np.concatenate((ynl1,ynl2), axis=0)
yfu = np.concatenate((ynu1,ynu2), axis=0)
xfl = np.concatenate((xnl1,xnl2),axis=0)
xfu = np.concatenate((xnu1,xnu2),axis=0)

xfl_rev = np.flip(xfl)
yfl_rev = np.flip(yfl)

#print the nodal coordinates
node_x = np.concatenate((xfl_rev,xfu), axis=0)
node_y = np.concatenate((yfl_rev,yfu), axis=0)



# plotting the Camber < p
plt.plot(x1, yc1, label = "")

# plotting the Camber > p 
plt.plot(x2, yc2, label = "")

# plotting the Upper surface < p
plt.plot(xu1, yu1, label = "")

# plotting the lower surface > p
plt.plot(xl1, yl1, label = "")

# plotting the Upper surface > p
plt.plot(xu2, yu2, label = "")

# plotting the Lower surface >p  
plt.plot(xl2, yl2, label = "")
# plotting the line 1 points 
# plt.plot(x1, yc1, label = "line 7")

# # plotting the line 2 points 
# plt.plot(x2, yc2, label = "line 2")

# plotting the lower surface
plt.plot(xfl, yfl, label = "")

# plotting the Panels upper surface 
plt.plot(xfu, yfu, label = "")

# plotting the Panel across upper and lower surface
plt.plot(xlast, ylast, label = "")


#printing nodal coordiantes to check their values
#print(node_x)
#print(" ")
#print(node_y)




# naming the x axis
plt.xlabel('x - axis')
# naming the y axis
plt.ylabel('y - axis')
# giving a title to my graph
plt.title('Airofil divided into panels')
  
# show a legend on the plot
plt.legend()
  
# function to show the plot
plt.show()



#Matrix P given i, x and y
def P_matrix(i,x,y):
  l = vector1((node_x[i]-node_x[i-1])*(node_x[i]-node_x[i-1]) + (node_y[i]-node_y[i-1])*(node_y[i]-node_y[i-1])   )
  co1 = np.array([[(x-node_x[i-1])/l],[(y -node_y[i-1])/l ]])
  co2 = np.array([[node_x[i]-node_x[i-1], node_y[i]-node_y[i-1] ], [-node_y[i]+node_y[i-1],node_x[i]-node_x[i-1]]] )
  panel_cord = np.dot(co2,co1)
  
  phi = (np.log((panel_cord[0][0]*panel_cord[0][0] + panel_cord[1][0]*panel_cord[1][0])/(   (panel_cord[0][0]-l)*(panel_cord[0][0]-l) + panel_cord[1][0]*panel_cord[1][0] )  ))/2
  psi = vector2((panel_cord[1][0]*l)/(panel_cord[0][0]*panel_cord[0][0] + panel_cord[1][0]*panel_cord[1][0] -panel_cord[0][0]*l))
  mat1 = np.array([[(node_x[i]-node_x[i-1])/(6.28318*l*l),(-node_y[i]+node_y[i-1])/(6.28318*l*l) ], [(node_y[i]-node_y[i-1])/(6.28318*l*l),(node_x[i]-node_x[i-1])/(6.28318*l*l)]])
  mat2 = np.array([ [(l-panel_cord[0][0])*phi + panel_cord[1][0]*psi, panel_cord[0][0]*phi - panel_cord[1][0]*psi   ]  , [  panel_cord[1][0]*phi -(l-panel_cord[0][0])*psi - l, -panel_cord[1][0]*phi - panel_cord[0][0]*psi + l]])
  P_matrix_out = np.dot(mat1,mat2)
  return P_matrix_out

cp1 = []
cp2 = []

for i in range(n-1):
  cp1.append((node_x[i]+node_x[i+1])/2)
  cp2.append((node_y[i]+node_y[i+1])/2)

cp_x = np.array(cp1)
cp_y = np.array(cp2)

A = []

for i in range(n):
  a =[]
  for j in range(n):
    a.append(0)
  A.append(a)

for i in range(n-1):
  l = vector1(  (node_x[i+1]-node_x[i])*(node_x[i+1]-node_x[i]) + (node_y[i+1]-node_y[i])*(node_y[i+1]-node_y[i])   )
  for j in range(n-1):
    A[i][j] = A[i][j] + ((node_x[i+1]-node_x[i])/l)*((P_matrix(j+1,cp_x[i],cp_y[i]))[1][0]) - ((node_y[i+1]-node_y[i])/l)*((P_matrix(j+1,cp_x[i],cp_y[i]))[0][0])
    A[i][j+1] = A[i][j+1] + ((node_x[i+1]-node_x[i])/l)*((P_matrix(j+1,cp_x[i],cp_y[i]))[1][1]) - ((node_y[i+1]-node_y[i])/l)*((P_matrix(j+1,cp_x[i],cp_y[i]))[0][1])

A[n-1][0] = 1
A[n-1][n-1] = 1


A_inv = np.linalg.inv(A)

alpha = 1
V_inf = 1

angle_mat = []
for i in range(n):
  a =[]
  for j in range(1):
    a.append(0)
  angle_mat.append(a)

for i in range(n-1):
 angle_mat[i][0] = V_inf*((node_y[i+1]- node_y[i])*np.cos(alpha)- (node_x[i+1]-node_x[i])*np.sin(alpha))  

nodal_strengths = np.dot(A_inv, angle_mat)

# Next task
# print(nodal_strengths)
second=[]
vel_mat=[]
first=[[V_inf*np.cos(alpha)],[V_inf*np.sin(alpha)]]
velocity=[]
for i in range(2):
  zero_mat =[]
  for j in range(1):
    zero_mat.append(0)
  second.append(zero_mat)
for i in range(n-1):
  for j in range(n-1):
    new_val1=nodal_strengths[j][0]  
    new_val2=nodal_strengths[j+1][0]  

    second+=np.dot(P_matrix(j+1,cp_x[i],cp_y[i]),[[new_val1],[new_val2]])
  vel_mat=first+second
  velocity.append(float(vector1(vel_mat[0]*vel_mat[0]+vel_mat[1]*vel_mat[1])))
  # print(velocity[i])
  # print('\n')
print(list(velocity))

# Cp
cp=[]
for i in range(len(velocity)):
  cp.append(1-velocity[i]*velocity[i]/V_inf*V_inf)
print(cp)





